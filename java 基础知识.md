---
title: java 基础知识 
tags: java
---


### 数组与内存控制
1.	对于JAVA程序中所有的引用变量，它们都不需要经过所谓的初始化操作，需要进行初始化操作的是该引用变量所引用的对象
2.	所有局部变量都是放在栈内存里保存的，不管其是基本类型的变量，还是引用类型的变量，都是存储在各自的方法栈区中；但引用类型变量所引用的对象（包括数组、普通JAVA对象）则总是存储在堆内存中。
这里说一下，每个线程都有自己的jvm栈，堆是线程共享的
![enter description here][1]


3. 对于JAVA语言而言，堆内存中的对象通常不允许直接访问，为了访问堆内存中的对象（包括数组、普通JAVA对象），通常只能通过引用变量。
4. 引用变量本质上只是一个指针，只要程序通过引用变量访问属性，或者通过调用引用变量来调用方法，该引用变量将会由它所引用的对象代替。
5. 当通过引用变量来访问实例属性，或者调用非静态方法时，如果该引用变量还未引用一个有效的对象，程序就会引发NullPointerException运行时异常。
6. 数组被初始化之后，该数组的长度是不可变的。JAVA程序中的数组必须经初始化才可使用。所谓初始化，就是为数组对象的元素分配内存空间，并为每个数组元素指定初始值。
7. 数组的初始化有以下两种方式：
（1）静态初始化：初始化时由程序员显式指定每个数组元素的初始值，由系统决定数组长度
例：String[] strs = new String[]{“hello”,”world”,”test”};
（2）	动态初始化：初始化时程序员只指定数组长度，由系统为数组元素分配初始值。
例：String[] strArr = new String[5];
不要同时使用静态初始化和动态初始化。也就是说，不要在进行数组初始化时，既指定数组的长度，也为每个数组元素分配初始值。
8. JAVA的数组是静态的，一旦为数组初始化完成，数组元素的内存空间分配即结束，程序只能改变数组元素的值，而无法改变数组的长度。JAVA的数组变量是一种引用类型的变量，数组变量并不是数组本身，它是指向堆内存中的数组对。
9. 对于基本类型数组而言，数组元素的值直接存储在对应的数组元素中，因此基本类型数组的初始化比较简单：程序直接先为数组分配内存空间，再将数组元素的值存入对应的内存里。
10. 引用类型数组的数组元素依然是引用类型的，因此数组元素里存储的还是引用，它指向另一块内存，这块内存里存储了该引用变量所引用的对象（包括数组和JAVA对象）。
![enter description here][2]

程序计数器：是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。
Java虚拟机栈：Java方法执行的内存模型，即每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。注：java虚拟机栈也是线程私有的，它与线程的生命周期相同。
本地方法栈：与java虚拟机栈的作用是非常相似的，其区别是虚拟机栈执行java方法服务，而本地方法栈是为虚拟机使用到的Native方法服务
JAVA堆：是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎有的对象实例都在这里分配内存。也是垃圾收集器管理的主要区域。
方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
### 对象与内存控制
1.	使用static修饰的成员变量是类变量，属于该类本身；没有使用static修饰的成员变量是实例变量，属于该类的实例。如果一个是实例变量，一个是类变量，则实例变量总是可以引用类变量，而类变量的初始化时机总是处于实例变量的初始化时机之前。
2.  对于static关键字而言，从词义上来看，它是“静态”的意思。但从JAVA程序的角度看，static的作用就是将实例成员变成类成员。static只能修饰在类里定义的成员部分，包括成员变量、方法、内部类、初始化块、内部枚举类。如果没有使用static修饰这些类里的成员，这里成员属于该类的实例；如果使用了static修饰，这些成员就属于类本身。从这个意义上看，static只能修饰类里的成员，不能修饰外部类，不能修饰局部变量、局部内部类。
3. 由于同一个JVM内每个类只对应一个Class对象，因此同一个JVM内的一个类的类变量只需一块内存空间；但对于实例变量而言，该类每创建一次实例，就需要为实例变量分配一块内存空间。类变量的初始化时机总是处于实例变量的初始化时机之前。
4. 大部分时候会把类和对象严格的区分开，但从另一个角度来看，类也是对象，所有类都是Class的实例。每个类初始化完成之后，系统都会为该类创建一个对应的Class实例，程序可以通过反射来获取某个类所对应的Class实例。
5. 对于实例变量而言，它属于JAVA对象本身，每次程序创建JAVA对象时都需要为实例变量分配内存空间，并执行初始化。
6. 定义实例变量时指定的初始值、初始化块中为实例变量指定的初始值、构造器中为实例变量指定的初始值，三者的作用完全类似，都用于对实例变量指定初始值。经过编译器处理之后，它们对应的赋值语句都被合并到构造器中。
7. 类变量属于JAVA类本身，只有当程序初始化该JAVA类时才会为该类的类变量分配内存空间，并执行初始化。JVM对一个JAVA类只初始化一次，因此JAVA程序每运行一次，系统只为类变量分配一次内存空间，执行一次初始化。
8. 从语法角度来看，程序可以再2个地方对类变量执行初始化：
（1）	定义类变量时指定初始值；
（2）	静态初始化块中对类变量指定初始值。
这两种方式的执行顺序与它们在原程序中排列顺序相同
9.	当创建任何JAVA对象时，程序总会先依次调用每个父类非静态初始化块，父类构造器（总是从Object开始）执行初始化，最后才调用本类的非静态初始化块、构造器执行初始化。
10.	super调用用于显示调用父类的构造器，this调用用于显示调用本类中另一个重载的构造器。super调用和this调用都只能在构造器中使用，而且super调用和this调用都必须作为构造器的第一行代码，因此构造器中的super调用和this调用最多只能使用其中之一，而且最多只能调用一次。
11.	如果在子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。对于实例变量则不存在这样的现象，即使子类中定义了与父类完全同名的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量。因为继承成员变量和继承方法之间存在这样的差别，所以对于一个引用类型的变量而言，当通过该变量访问它所引用的对象的实例变量时，该实例变量的值取决于声明该变量时类型；当通过该变量来调用它所引用的对象的方法时，该方法行为取决于它所实际引用的对象的类型。
12.	当程序创建一个子类对象时，系统不仅会为该类中定义的实例变量分配内存，也会为其父类中定义的所有实例变量分配内存，即使子类定义了与父类中同名实例变量。
13.	final修饰符：被修饰的变量赋初始值之后不能对它重新赋值；被修饰的方法不能被重写；被修饰的类不能派生子类。
被final修饰的变量必须显示指定初始值，而且只能在如下3个位置指定初始值：
（1）定义final实例变量时指定初始值；
（2）在非静态初始化块中为final实例变量指定初始值；
（3）在构造器中为final实例变量指定初始值。
对于普通实例变量，JAVA程序可以对它执行默认的初始化，也就是将实例变量的值指定为默认的初始值0或null，但对于final实例变量，则必须由程序员显示指定初始值
14.	对一个final变量，不管它是类变量、实例变量，还是局部变量，只要定义该变量时使用了final修饰符，并在定义时指定了初始值，而且该处是可以在编译时就被确定下来，那么这个final变量本质上已经不再是变量，而是相当于一个直接量。
15.	匿名内部类中的局部变量：如果程序需要在匿名内部类中使用局部变量，那么这个局部变量必须使用final修饰符修饰。
16.	JAVA会缓存所用曾经用过的字符串直接量。例如执行String a = “java”;语句之后，系统的字符串池中就会缓存一个字符串”java”;如果程序再次执行String b = “java”;，系统将会让b直接指向字符串池中的”java”字符串，因此a==b将会返回true。
### 常见JAVA集合的实现细节
1. Set代表一种集合元素无序、集合元素不可重复的集合，Map则代表一种由多个key-value对组成的集合，Map集合类似于传统的关联数组
2. 虽然集合号称存储的是JAVA对象，但实际上并不会真正将JAVA对象放入Set集合中，而只是在Set集合保留这些对象的引用。也就是说，JAVA集合实际上多个引用变量所组成的集合，这些引用变量指向实际的JAVA对象。
3. 对于HashMap及其子类而言，它们采用Hash算法来决定集合中元素的存储位置。当系统开始初始化HashMap是，系统会创建一个长度为capacity的Entry数组。这个数组里可以存储元素的位置被称为“桶（bucket）”，每个bucket都有其指定的索引，系统可以根据其索引快速访问该bucket里存储的元素。无论何时，HashMap的每个“桶”只存储一个元素。由于Entry对象可以包含一个引用变量用于指向下一个Entry，因此可能出现：HashMap的bucket中只有一个Entry，但这个Entry指向另一个Entry——这就形成了一个Entry链。当HashMap的每个bucket里存储的Entry只是单个Entry，既没有通过指针产生Entry链时，此时的HashMap具有最好的性能
4. HashMap包含以下几个构造器：
HashMap()：构建一个初始容量为16，负载因子为0.75的HashMap。
HashMap(int initialCapacity)：构建一个初始容量为initialCapacity，负载因子为0.75的HashMap。
HashMap(int initialCapacity , float laodFactor)：以指定初始容量，指定负载因子创建一个HashMap。
5. 创建HashMap时指定的initialCapacity并不等于HashMap的实际容量。通常来说，HashMap的实际容量总比initialCapacity大一些，除非指定的initialCapacity参数值恰好是2的n次方。
6.	当程序试图将一个key-value对放入HashMap中时，首先根据该key的hashCode()返回值决定该Entry的存储位置：如果两个Entry的key的hashCode()返回值相同，那他们的存储位置相同；如果这两个Entry的key通过equals比较返回true，新添加Entry的value将覆盖集合中原有Entry的value，但key不会覆盖；如果这两个Entry的key通过equals比较返回false，新添加的Entry将与集合中原有Entry形成Entry链，而且新添加的Entry位于Entry链的头部
7. 如果开始就知道HashMap会保存多个key-value对，可以在创建时就用较大的初始化容量，如果HashMap中Entry的数量一直不会超过极限容量（capacity * load factor），HashMap就无需调用resize()方法重新分配table数组，从而保证较好的性能。
8. HashSet是基于HashMap实现的。HashSet底层采用HashMap来保存所有元素，因此HashSet的实现比较简单。所有放入HashSet中的集合元素实际上由HashMap的key来保存，而HashMap的value则存储了一个PRESENT，它是一个静态的Object对象。
9. TreeMap底层采用一棵“红黑树”来保存集合中的Entry，这意味着TreeMap添加元素、取出元素的性能都比HashMap低。当TreeMap添加元素时，需要通过循环找到新增Entry的插入位置；当从TreeMap中取出元素时，需要通过循环才能找到合适的Entry，比较耗性能。但TreeMap、TreeSet相比HashMap、HashSet的优势在于：TreeMap中的所有Entry总是key根据指定排序保持有序状态，TreeSet中的所有元素总是根据指定排序规则保持有序状态。
10. 在List集合的实现类中，主要有3个实现类：ArrayList、Vector和LinkedList。Vector和ArrayList这两个集合类本质并没有太大的不同，他们都实现了List接口，从序列化机制的角度看，ArrayList的实现比Vector的实现更安全，Vector其实就是ArrayList的线程安全版本。
11. ArrayList和Vector底层都是基于JAVA数组来实现的，ArrayList总是将底层数组容量扩充为原来的1.5倍，但Vector则多了一个选择：当创建Vector可以传入一个capacityIncrement参数，该值大于0时，扩充后的容量等于原来的容量加上capacityIncrement的值。
12. List代表一种线性表的数据结构，ArrayList则是一种顺序存储的线性表，LinkedList则是一种链式存储的线性表。
13. 对于ArrayList集合而言，当程序调用add(int index , Object obj) 或者remove(int index)，ArrayList底层都需要对数组进行“整体搬家”，因此性能非常差。但如果程序调用get(int index) 方法取出ArrayList集合中的元素时，性能非常快。当程序调用add(Object obj) 方法向List集合尾端添加一个元素时，大部分时候ArrayList无需对底层数组元素进行“整体搬家”，因此也可获得很好的性能，但如果添加这个元素导致集合长度超过底层数组长度，那么ArrayList必须创建一个长度为原来长度1.5倍的数组，再由垃圾回收机制回收原有数组，这样系统开销就比较大了。
14. 对于LinkedList集合而言，它的主要开销集中在add(int index, E element)方法上，该方法必须一个一个的搜索过去，直到找到index处的元素，然后再在该元素之前插入新元素。当把LinkedList当成双端队列、栈使用，调用addFirst(E e) 、addLast(E e) 、getFirst(E e) 、getLaset(E e) 、offer(E e) 、offerFirst(E e)、offerLast(E e) 等方法来操作集合元素时LinkedList可以快速定位需要操作的元素。
15. 大部分情况下，ArrayList的性能总是优于LinkedList，因此绝大部分都应该考虑使用ArrayList集合。但如果程序经常需要添加、删除元素时，则应该考虑使用LinkedList集合。
### JAVA的内存回收
1. 当JAVA对象被创建出来以后，垃圾回收机制会实时地监控每一个对象的运行状态，包括对象向的申请、引用、被引用、赋值等。当垃圾回收机制实施的监控到某个对象不再被引用变量所引用是，立即回收机制就会回收它所占用的空间。
2. 当一个对象在堆内存中运行时，根据它在对应有向图中的状态，可以把它的状态分成：可达状态、可恢复状态和不可达状态。
3. 当某个对象被其他类的类变量引用时，只有该类被销毁后，该对象才会进入可恢复状态；当某个对象被其他对象的实例变量引用时，只有当引用该对象的对象被销毁或变成不可达状态后，该对象才会进入不可达状态。

4. JAVA语言对对象的引用有如下4种：
**强引用**:这是JAVA程序中最常见的引用方式，程序创建一个对象，并把这个对象赋给一个引用变量，这个引用变量就是强引用。(由于JVM肯定不会回收强引用所引用的JAVA对象，因此强引用是造成JAVA内存泄露的主要原因之一)
**软引用**:软引用需要通过java.long.ref.SoftReference类来实现，当一个对象只具有软引用是，它有可能被垃圾回收机制回收。对于只有软引用的对象而言，当系统内存空间足够时，它不会被系统回收，程序也可使用该对象；当系统内存空间不足时，系统将会回收它。
**弱引用**：弱引用通过java.long.ref.WeakReference类或java.util.WeakHashMap来实现，弱引用和软引用很像，但弱引用的引用级别更低。对于只有弱引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，总会回收该对象所占用的内存。注意：采用String str = “hello”;代码定义字符串时，系统会缓存这个字符串直接量（会使用强引用来引用它），系统不会回收被缓存的字符串常量。
**虚引用**：就是跟踪对象被垃圾回收的状态，通过java.long.ref.PhantomReference类实现，它完全类似于没有引用。程序可以通过检查与虚引用关联的引用队列中是否已经包含指定的虚引用，从而了解虚引用所引用对象是否即将被回收。引用队列由java.lang.ref.ReferenceQueue类表示，它用于保存被回收后对象的引用。当把软引用、弱引用和引用队列联合使用时，系统回收被引用的对象之后，将会把被回收对象对应的引用添加到关联的引用队列中。与软引用和弱引用不同的事，虚引用在对象被释放之前，将把它对应的虚引用添加到它的关联的引用队列中，这使得可以在对象被回收之前采取行动。

5. 内存泄露：程序运行过程中会不断的分配内存空间，那些不再使用的内存空间应该即时回收它们，从而保证系统可以再次使用这些内存，如果存在无用的内存没有被回收回来，那就是内存泄露。
6.	现行的垃圾回收器用分代的方式来采用不同的回收设计。分代的基本思路是根据对象生存时间的长短，把堆内存分成3个代：Young、Old、Permament。
Young代：采用复制算法只需遍历那些处于可达状态的对象，而且这些对象的数量较少，可复制成本也不大，因此可以充分发挥复制算法的优点。
Old代：如果Young代中对象经过数次垃圾回收依然还没有被回收掉，即这个对象经过足够长的时间还处于可达状态，垃圾回收机制就会将这个对象转移到Old代。垃圾回收器通常会使用标记压缩算法，这种算法可以避免复制Old代的大量对象，而且由于Old代的对象不会很快死亡，回收过程不会大量地产生内存碎片，因此相对比较划算。
Permanent：主要用于装载Class、方法等信息，默认为64M，垃圾回收机制通常不会回收Permanent代中的对象。注：对于那些需要加载很多类的服务器程序，往往需要加大Permanent代内存，否则可能因为内存不足而导致程序终止。
7.	垃圾回收的附加选项：
-Xmx :设置JAVA虚拟机堆内存的最大容量，例：java -Xmx256m XxxClass
-Xms :设置JAVA虚拟机堆内存的初始容量，例：java -Xms128m XxxClass
-XX:NewSize=size :设置Young代内存的默认容量，例：java --XX:NewSize=64m XxxClass
-XX:MaxNewSize=size :设置Young代内存的最大容量，例：java --XX:MaxNewSize=128m XxxClass
-XX:PermSize=size :设置Permanent代内存的默认容量，例：java -XX:PermSize=128m XxxClass
-XX:MaxPermSize=size :设置Permanent代内存的最大容量，例：java -XX:MaxPermSize=128m XxxClass
-XX:+PrintGCDetails 显示GC的详细信息
-XX:+PrintGCApplicationConcurrentTime 打印应用执行的时间
-XX:+PrintGCApplicationStoppedTime 打印应用被暂停的时间
8.	常见垃圾回收器：
串行回收器：通过运行JAVA程序时使用-XX:+UseSerialGC附加选项启用。对Young代和Old代的回收都是串行的（只使用一个CPU），而且垃圾回收执行期间会使得应用程序产生暂停。具体策略为，Young代采用串行复制的算法，Old代采用串行标记压缩算法。
并行回收器：通过运行JAVA程序时使用-XX:+UseParallelGC附加选项启用。他可以充分利用计算机的多个CPU来提高垃圾回收吞吐量。
并行压缩回收器：通过运行JAVA程序时使用-XX:+UseParallelOldGC附加选项启用，一样可通过-XX:ParallelGCThreads=size来设置并行线程的数目。并行压缩回收器是在J2SE5.0 update6开始引入的，它和并行回收器最大的不同是对Old代的回收使用了不同的算法，并行压缩回收期最终会取代并行回收器。
并发回收器（CMS）：通过运行JAVA程序时使用-XX:+UseConcMarkSweepGC附加选项启用。CMS回收器对Young代的回收方式和并行回收器的回收方式完全相同。由于对Young的回收依然采用复制回收算法，因此垃圾回收时依然会导致程序暂停，除非依靠多CPU并行来提高垃圾回收的速度。
9.	内存管理优化：
尽量使用直接量：当使用字符串，还有Byte、Short、Integer、Long、Float、Double、Boolean、Character包装类的实例时，程序不应该采用new的方式来创建对象，而应该直接采用直接量来创建它们。
使用StringBuilder和StringBuffer进行字符串连接：String、StringBuilder、StringBuffer都可代表字符串，其中String代表字符序列不可变的字符串，而StringBuidler和StringBuffer都代表字符序列可变的字符串。
尽早释放无用对象的引用：大部分时候，方法局部引用变量所引用的对象会随着方法结束而变成垃圾，因为局部变量的生存期限很短，当方法运行结束之时，该方法内的局部变量就结束了生命期限。
尽量少用静态变量：如果某个对象被static变量所引用，那么垃圾回收机制通常是不会回收这个对象所占的内存。
尽量避免在经常调用的方法、循环中创建JAVA对象
缓存经常使用的对象：如果有些对象需要被经常使用，可以考虑把这些对象用缓存池保存起来，这样当下次需要时就可直接拿出这些对象来用。
尽量不要使用finalize方法：在垃圾回收器本身已经严重制约应用程序性能的情况下，如果再选择使用finalize()方法进行资源清理，无疑是一种火上浇油的行为，这将导致垃圾回收器的负担更大，导致程序运行效率更差。
考虑使用SoftReference：当程序需要创建长度很大的数组时，可以考虑使用SoftReference来包装数组元素，而不是直接让将数组元素来引用对象。

### 表达式中的陷阱
1.	对于JAVA程序中的字符直接量，JVM会使用一个字符串池保存它们：当第一次使用某个字符串直接量时，JVM会将它放入字符串池进行缓存。在一般情况下，字符串池中字符串对象不会被垃圾回收，当程序再次需要使用该字符串时，无需重新创建一个新的字符串，而是直接让引用变量指向字符串池中已有的字符串。
2.	了通过字符串直接量创建字符串对象之外，也可以通过字符串连接表达式来创建字符串对象，因此也可将一个字符串连接表达式来创建字符串对象，因此也可将一个字符串连接表达式赋给字符串变量。如果这个字符串连接表达式的值可以在编译时确定下来，那么JVM会在编译时计算该字符串变量的值，并让他指向字符串池中对应的字符串。
例：String str1 = “Hello Java” ;
String str2 = “Hello” + “Java” ;
System.out.println( str1==str2 ); // 输出结果为：true
3.	如果程序使用了变量，或者调用了方法，那就只能等到运行时才可确定该字符串连接表达式的值，也就无法在编译时确定该字符串变量的值，因此无法利用JVM的字符串池。当然有一种情况例外，如果字符串连接运算中的所有变量都可执行“宏替换”（final修饰的直接量），那么JVM 一样可以在编译时就确定字符串连接表达式的值，一样会让字符串变量指向JVM字符串池中的对应字符串。
4. 当程序中需要使用字符串、基本类型包装类实例时，应该尽量使用字符串直接量、基本类型值的直接量，避免通过new String() 、new Integer() 的形式来创建字符串、基本类型包装类实例，这样能保证较好的性能。
5.	String类是一个典型的不可变类。当一个String对象创建完成后，该String类里包含的字符序列就被固定下来了，以后永远都不能改变。
例：String str = “Hello”;
    str = str + “JAVA”;
str变量原来指向的字符串对象并没有发生任何改变，它所包含的字符序列依然是“Hello”，只是str变量不再指向它而已，它也许以后永远都不会再被用到，但这个字符串并不会被垃圾回收，因为它将一直存在于字符串池中——这就是JAVA内存泄露的原因之一。
6.	对于String类而言，它代表字符串序列不可改变的字符串，因此如果程序需要一个字符序列会发生改变的字符串，那应该考虑使用StringBuilder和StringBuffer。StringBuilder和StringBuffer唯一的区别在于，StringBuffer时线程安全的，也就是说StringBuffer类里绝大部分方法都增加了synchronized修饰符。对方法增加synchronized修饰符可以保证该方法线程安全，但会降低该方法的执行效率。
7.	如果在编译JAVA程序时编译提示形如“非法字符：\xxxxx”的错误提示，那么就可断定该JAVA程序中包含“全角字符”，JAVA程序中通常不能包含“全角字符”，但JAVA程序的字符串中完全可以包含“全角字符”，JAVA程序的注释中也可以包含“全角字符”。
8. JAVA对待Unicode转义字符时不会进行任何处理，它会将Unicode转义字符直接替换成对应的字符，这将给JAVA程序带来一些潜在的陷阱。
9. 泛型的注意点：
（1）当程序把一个原始类型的变量赋给一个带泛型信息的变量时，总是可以通过编译，只是会提示一些警告信息。
（2）当程序试图访问带泛型声明的集合元素时，编译器总是把集合元素当成泛型类型处理，它并不关心集合里集合元素实际类型。
（3）当程序试图访问带泛型声明的集合的集合元素时，JVM会遍历每个集合元素自动执行强制转型，如果集合元素的实际类型与集合所带的泛型信息不匹配，运行时将引发ClassCastException。
10.	当把一个具有泛型信息的对象赋给一个没有泛型信息的变量时，所有在尖括号之间的类型信息都将被丢弃。
11.	从JDK 1.5开始，JAVA提供了3种方式来创建、启动多线程：
（1）	继承Thread类来创建线程类，重写run()方法作为线程执行体。
（2）	实现Runnable接口来创建线程类，重写run()方法作为线程执行体。
（3）	实现Callable接口来创建线程类，重写call()方法作为线程执行体。
12.	JAVA语法规定，任何线程进入同步方法、同步代码块之前，必须先获取同步方法、同步代码块对应的同步监视器。对于同步代码块而言，程序必须显示为它指定同步监视器；对于非静态方法而言，该方法的同步监视器this——即调用该方法的JAVA对象；对于静态的同步方法而言，该方法的同步监视器不是this，而是该类本身。

### 面向对象的陷阱

 1. instanceof运算符除了可以保证某个引用变量是特定类型的实例外，还可以保证该变量没有引用一个null。这样就可以将该引用变量转型为该类型，并调用该类型的方法，而不用担心会引发ClassCastException或NullPointerException异常。
 2. 根据JAVA语言规范，使用instanceof运算符有一个限制：instanceof运算符前面操作数的编译时类型必须是如下3种情况：
（1）	要么与后面的类相同；
（2）	要么是后面类的父类；
（3）	要么是后面类型的子类。
如果前面操作数的编译时类型与后面的类型没有任何关系，程序将没法通过编译。在极端情况下，instanceof前面一个操作数所引用对象的实际类型就是后面的类型，但只要它的编译时类型既不是第二个操作数的类型，也不是第二个操作数的父类、子类，程序就没法通过编译。
 3. 构造器并不会创建JAVA对象，构造器只是负责执行初始化，在构造器执行之前，JAVA对象所需要的内存空间，应该说是由new关键字申请出来的。绝大部分时候，程序使用new关键字为一个JAVA对象申请空间之后，都需要使用构造器为这个对象执行初始化。但在某些时候，程序创建JAVA对象无需调用构造器，以下两种方式创建的JAVA对象无需使用构造器：
（1）	使用反序列化的方式恢复对象；
（2）	使用clone方法复制JAVA对象。
 4. 当为构造器声明添加任何返回值类型声明，或者添加void声明该构造器没有返回值时，编译器并不会提示这个构造器有错误，只是系统会把这个所谓的“构造器”当成普通方法处理。
 5. 无论如何不要导致构造器产生递归调用。也就是说，应该：
（1）	尽量不要在定义实例变量时指定实例变量的值为当前类的实例；
（2）	尽量不要初始化块中创建当前类的实例；
（3）	尽量不要在构造器内调用本构造器创建JAVA对象。
 6. 对一个JAVA类而言，它的一个实例持有当前类的另一个实例的引用是被允许的，只要程序初始化它所持有当前类的实例时不会引起构造器递归。
 7. JAVA的重载解析过程分成以下两个阶段：
（1）	第一阶段JVM将会选取所有可获得并匹配调用的方法或构造器。
（2）	第二阶段决定到底要哪个方法，此时JVM会在第一阶段所选取的方法或构造器中再次选取最精确匹配的那一个。
 8. 对于private修饰符修饰的方法，只能在当前类中访问到该方法，子类无法访问父类中定义的private方法。既然子类无法访问父类的private方法，当然也就无法重写该方法。
 9. 对于不使用访问控制符修饰的方法，它只能被与当前类处于同一包中的其他类访问，其它包中的子类依然无法访问。
 10. 内部类能提供更好的封装，而且它可以直接访问外部类的private成员。
 11. 非静态内部类必须寄生在外部类的实例中，没有外部类的对象，就不可能产生非静态内部类的对象。因此，非静态内部类不可能有无参数的构造器——即使系统为非静态内部类提供一个默认的构造器，这个默认构造器也需要一个外部类形参。系统在编译阶段总会为非静态内部类构造器增加一个参数，非静态内部类的构造器的第一个形参类型总是外部类。
 12. 对于非静态内部类而言，由于它本身就是一个非静态的上下文环境，因为非静态内部类不允许拥有静态成员。
 13. 当程序使用静态内部类时，外部类相当于静态内部类的一个包，因此使用起来比较方便；另外这也给静态内部类增加了一个限制——静态内部类不能访问外部类的非静态成员。

### java 容器
**容器类的层级**
```
Collection （用来存放独立元素的序列）
├List 
│├LinkedList 
│├ArrayList 
│└Vector 
│　└Stack 
└Set 
 ├HashSet
 └TreeSet
Map （用来存放key-value型的元素对）
├Hashtable 
├HashMap 
├TreeMap 
└WeakHashMap
```

 1. List

```
List是有序的Collection，使用此接口能控制每个元素插入的位置，用户能够使用索引来访问元素。与Set不同的是，List允许有重复的元素在其中。
```
**ArrayList**

ArrayList相当于顺式存储（线性表），当实例化一个ArrayList时，一个数组也被实例化了，默认初始化一个长度为10的数组。当添加数据的时候会判断当前容量是否能够容下新增的对象，一旦发现容量不足，会自动扩容，新的大小为原有容量的1.5倍+1。

ArrayList可以快速随机访问，通过调用get(i)方法来访问下标为i的元素。

**LindedList**

LinkedList相当于链式存储（双向链表），它是通过节点直接彼此连接来实现的。每一个节点都包括前一个节点的引用，后一个节点的引用和节点存储的值。
当插入或删除节点时，只需要修改其中保持先后关系的节点的引用即可，所以，操作其中的对象速度比ArrayList要快的多。

但是LinkedList不能随机访问元素，虽然它有get()方法，但是这个方法是通过遍历节点来定位的，速度很慢。

**Vector**

Vector和ArrayList一样，也是用数组来存储元素。但是Vector使用了synchronized方法，线程安全，所以在性能上比ArrayList要差。

**ArrayList和LinkedList的区别**
ArrayList实现了基于动态数组的数据结构，LinkedList实现了基于链表的数据结构
对于随机访问get和set，ArrayList优于LinkedList
对于增删add和remove，LinkedList优于ArrayList

 2. Set

Set是一种不包含重复元素的Collection，它的构造函数有一个约束条件，传入的Collection参数不能包含重复的元素。

**HashSet**
HashSet实现了Set接口，由哈希表支持。它不保证Set的迭代顺序，特别是它不保证该顺序恒久不变。

HashSet底层使用的容器实际上就是HashMap，它以HashMap的key来保存所有的元素，value使用一个static final的Object对象来标识

**TreeSet**

TreeSet整体上性能没有HashSet好，但是它可以维持元素的排序状态。

TreeSet底层使用的容器实际上就是TreeMap，它以TreeMap的key来保存set集合的元素，value都以一个名为PRESENT的Object对象代替（无实际意义）。

 3. Map

Map接口提供key到value的映射，一个Map不能包含相同的key，每个key只能映射一个value。

**HashMap**
HashMap底层就是一个数组结构，数组中的每一项又是一个链表(其实就是哈希表的拉链法实现)。但是此类不保证映射的顺序，特别是不保证该顺序恒久不变。但是TreeMap可以维持映射的顺序。

**Hashtable**
和HashMap实现差不多，具体区别见下面的Hashtable和HashMap的区别。

**TreeMap**
TreeMap的底层实现是一个红黑树结构，这样可以保证快速检索节点，TreeMap可以维持映射的顺序。

下面我们来具体说下TreeMap的底层实现，首先我们需要了解下排序二叉树：
```
排序二叉树：要么是一棵空二叉树，要么是具有下列性质的二叉树：
若它的左子树不为空，则左子树上所有节点的值均小于根节点的值
若它的右子树不为空，则右子树上所有节点的值均大于根节点的值
它的左右自子树也分别为排序二叉树
--------------------------------
对于排序二叉树，它的中序遍历就可以得到由小到大的有序序列，所以用它就可以实现快速检索，但是为什么Java还要多此一举用红黑树呢？
--------------------------------
```

排序二叉树虽然可以快速检索，但是在最坏情况下：若插入的节点本身就是有序的，要么由小到大排列，要么由大到小排列，那么最后得到的排序二叉树就变为了链表：所有的节点只有左节点或者所有的节点只有右节点。这种情况下，排序二叉树就变为了普通链表，检索效率会很差。

所以，Java引入了红黑树作为TreeMap的底层实现
红黑树：红黑树是一种更高效的检索二叉树，它的性质为：

所有的节点都为红色或者黑色
根节点永远是黑色
所有的叶节点都是空节点（NULL），并且是黑色
每个红色节点的两个子节点都是黑色，即从根节点到叶子节点的路径上不会出现两个连续的红色节点。
从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点

红黑树通过上面的限制来保证它大致是平衡的（因为红黑树的高度不会无限增高），这样保证了红黑树在最坏情况下都是高效的，不会出现普通排序二叉树的情况。

**Hashtable和HashMap的区别**
继承和实现不同
Hashtable是继承自陈旧的Dictionary类，实现了Map接口；HashMap实现接口（继承自AbstractMap，AbstractMap实现Map接口）

线程安全不同
Hashtable是线程安全的，它的实现方法里面都添加了synchronized关键字来确保线程同步。HashMap是线程不安全的，在多线程编程下如使用HashMap需要使用Collections.synchronizedMap()来获取一个线程安全的集合。

对null的处理不同
HashMap支持null作为key和value，但是Hashtable不允许（key，value都不允许）。HashMap的方法get()返回null时，既可以表示没有改键，也可以表示该键对应的值为null，所以不能用此判断是否有该键，而应该用containsKey()。

HashMap初始容量为16，Hashtable初始容量为11。HashMap扩容时是当前容量翻倍：capacity2，Hashtable是当前容量翻倍+1：capacity2+1。

哈希值的使用不同
Hashtable直接使用key的hashcode对table数组的长度取模，HashMap是对key的hashcode进行二次hash，然后对table数组的长度取模，以获得更好的散列值。

  [1]: ./images/%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84_1.jpg "线程结构"
  [2]: ./images/Jvm%E7%BB%93%E6%9E%84.jpg "Jvm结构"
  
  